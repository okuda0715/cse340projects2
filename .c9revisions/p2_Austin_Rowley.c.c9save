{"ts":1380577859866,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*Austin Rowley\n  cse340\n  project 1\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <string.h>\n\n#define TRUE  1\n#define FALSE 0\n\n#define DEBUG 1     // 1 => Turn ON debugging, 0 => Turn OFF debugging\n\nvoid print_debug(const char * format, ...)\n{\n    va_list args;\n    if (DEBUG)\n    {\n        va_start (args, format);\n        vfprintf (stdout, format, args);\n        va_end (args);\n    }\n}\n\n//----------------------------- token types ------------------------------\n#define KEYWORDS \t12\n#define RESERVED \t38\n#define VAR \t\t1\n#define BEGIN \t\t2\n#define END \t\t3\n#define ASSIGN \t\t4\n#define IF \t\t\t5\n#define WHILE \t\t6\n#define DO \t\t\t7\n#define THEN \t\t8\n#define PRINT \t\t9\n#define INT \t\t10\n#define REAL \t\t11\n#define STRING \t\t12\n#define PLUS \t\t13\n#define MINUS \t\t14\n#define UNDERSCORE \t15\n#define DIV \t\t16\n#define MULT \t\t17\n#define EQUAL \t\t18\n#define COLON \t\t19\n#define COMMA \t\t20\n#define SEMICOLON \t21\n#define LBRAC \t\t22\n#define RBRAC \t\t23\n#define LPAREN \t\t24\n#define RPAREN \t\t25\n#define NOTEQUAL \t26\n#define GREATER \t27\n#define LESS \t\t28\n#define LTEQ \t\t29\n#define GTEQ \t\t30\n#define LSHIFT \t\t31\n#define RSHIFT \t\t32\n#define DOT \t\t33\n#define NUM \t\t34\n#define INTID \t\t35\n#define REALID \t\t36\n#define ID \t\t\t37\n#define ERROR \t\t38\n\n//------------------- reserved words and token strings -----------------------\nchar *reserved[] =\n\t{\t\"\",\n\t\t\"VAR\",\n\t\t\"BEGIN\",\n\t\t\"END\",\n\t\t\"ASSIGN\",\n\t\t\"IF\",\n\t\t\"WHILE\",\n\t\t\"DO\",\n\t\t\"THEN\",\n\t\t\"PRINT\",\n\t\t\"INT\",\n\t\t\"REAL\",\n\t\t\"STRING\",\n\t\t\"+\",\n\t\t\"-\",\n\t\t\"_\",\n\t\t\"/\",\n\t\t\"*\",\n\t\t\"=\",\n\t\t\":\",\n\t\t\",\",\n\t\t\";\",\n\t\t\"[\",\n\t\t\"]\",\n\t\t\"(\",\n\t\t\")\",\n\t\t\"<>\",\n\t\t\">\",\n\t\t\"<\",\n\t\t\"<=\",\n\t\t\">=\",\n\t\t\"<<\",\n\t\t\">>\",\n\t\t\".\",\n\t\t\"NUM\",\n\t\t\"INTID\",\n\t\t\"REALID\",\n\t\t\"ID\",\n\t\t\"ERROR\"\n\t\t};\n\nint printReserved(int ttype)\n{\n\tif (ttype <= RESERVED)\n\t{\n\t\tprintf(\"%s\\n\",reserved[ttype]);\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n//---------------------------------------------------------\n\n//---------------------------------------------------------\n// Global Variables associated with the next input token\n// This implementation does not allow tokens that are more\n// than 100 characters long\n#define MAX_TOKEN_LENGTH 100\n\nchar token[MAX_TOKEN_LENGTH];     // token string\nint  tokenLength;\nint  line_no = 0;\n\n//---------------------------------------------------------\n// Global Variables associated with the input buffer\n// This implementation does not allow lines that are more\n// than 500 characters long\n#define BUFFER_SIZE     500\n\nint buffer[BUFFER_SIZE];\nint start_pos   = 0;\t// Signifies the start position in the buffer (#)\nint next_pos    = 0;\t// Signifies the next character to be read (^)\nint maximal_pos = 0;\t// Signifies the last character of the maximal \n                        // token found (*)\n\n//---------------------------------------------------------\n// Functions associated with the input buffer\n\nvoid readNextLine()\n{\n\tint  i;\n\tchar c;\n\tstart_pos   = -1; // start position is the position just\n                      // before the beginning of the token string\n\tmaximal_pos = -1; // maximal_position points to the end of the\n                      // maximal_matched token string\n\tnext_pos    = 0;  // next_pos points to the next input character\n\n\ti = 0;\n\tc = getchar();\n\twhile (c != '\\n' && !feof(stdin) && (i < BUFFER_SIZE))\n\t{\n\t\tbuffer[i] = c;\n\t\tc = getchar();\n\t\ti++;\n\t}\n\tif (i >= BUFFER_SIZE)\n\t{\n\t\tprintf(\"Maximum allowed line length exceeded\\n\");\n\t\texit(1);\n\t}\n\telse\n\t\tbuffer[i] = EOF;\n\tline_no++;\n}\n\n/* you can use the following function for Debugging purposes */\nvoid printBuffer()\n{\n\tprint_debug(\"BUFFER: \");\n\tint i = 0;\n\twhile (buffer[i] != EOF)\n\t{\n\t\tprint_debug(\"%c\", (char) buffer[i]);\n\t\ti++;\n\t}\n\tprint_debug(\"\\n\");\n\tprint_debug(\"START_POS   = %d\\n\", start_pos);\n\tprint_debug(\"NEXT_POS    = %d\\n\", next_pos);\n\tprint_debug(\"MAXIMAL_POS = %d\\n\", maximal_pos);\n}\n\nint skip_space_and_set_positions()\n{\n\twhile (isspace((char) buffer[next_pos]))\n\t{\n\t\tnext_pos++;\n\t}\n\tmaximal_pos = next_pos - 1;\n\tstart_pos   = next_pos - 1;\n\treturn 0;\n}\n\n// this function copies the maximal token string to the token array\n// it assumes the token string is not empty\nvoid copy_token_string_from_buffer()\n{\n\tint i;\n\ttokenLength = 0;\n\tfor (i = start_pos + 1; i <= maximal_pos; i++)\n\t{\n\t\ttoken[tokenLength] = (char) buffer[i];\n\t\ttokenLength++;\n\t}\n\ttoken[tokenLength] = '\\0';\n}\n\n//----------------------------------------------------------\n\n// This function checks if a string is a keyword. \n// The implementation is not the most efficient, but probably \n// the simplest!\nint isKeyword(char *s)\n{\n\tint i;\n\n\tfor (i = 1; i <= KEYWORDS; i++)\n\t\tif (strcmp(reserved[i],s) == 0)\n\t   \t\treturn i;\n\treturn FALSE;\n}\n\nint scan_id_keyword_intid_realid()\n{\n\tint ttype;\n\n    //scan while its a letter or digit\n\twhile (isalnum(buffer[next_pos])) {\n\t\tnext_pos++;\n\t}\n\t\n\t//keep track of the maximum matched token\n\tmaximal_pos = next_pos - 1;\n\t\n\t//its on track for INTID and REALID\n\tif (buffer[next_pos] == '.') {\n\t    next_pos++;\n\t    \n\t    //still on track for INTID and REALID\n\t    if (isdigit(buffer[next_pos])) {\n\t     \n\t        //loop through while its still a digit\n\t        if (buffer[next_pos] != '0')\n\t\t        while (isdigit(buffer[next_pos]))\n\t\t\t        next_pos++;\n\t        else // NUM is 0\n\t\t        next_pos++;\n\t        \n\t        //check for INTID = ID DOT NUM (I)(N)(T)\n\t        if (buffer[next_pos] == 'I' && buffer[next_pos + 1] == 'N' && buffer[next_pos + 2] == 'T') {\n\t            ttype = INTID;\n\t            maximal_pos = next_pos + 2;     //maximum token is the INTID\n\t            next_pos = maximal_pos + 1;\n\t            copy_token_string_from_buffer();\n\t           \n\t        }\n\t        //check for REALID = ID DOT NUM (R)(E)(A)(L)\n\t        else if (buffer[next_pos] == 'R' && buffer[next_pos + 1] == 'E' && buffer[next_pos + 2] == 'A' && buffer[next_pos + 3] == 'L') {\n\t            ttype = REALID;\n\t            maximal_pos = next_pos + 3;     //maximum token is the REALID\n\t            next_pos = maximal_pos + 1;\n\t            copy_token_string_from_buffer();\n\t           \n\t        }\n\t        //in the case of ie. \"var.1IN\"\n\t        else {\n\t            copy_token_string_from_buffer();\n\t            next_pos = maximal_pos + 1;\n\t            ttype = isKeyword(token);\n\t        }\n\t    }\n\t    //in the case of ie. \"var.hello\"\n\t    else {\n\t        copy_token_string_from_buffer();\n\t        next_pos--;     //the next token should start at '.'\n\t        ttype = isKeyword(token);\n\t    }\n\t}\n\t//in the case if the current char is anything other than '.', then token must be an ID or KEYWORD\n\telse {\n\t    copy_token_string_from_buffer();\n\t    ttype = isKeyword(token);\n\t}\n\t\n\t//take account for when ttype is just ID\n\tif (ttype == 0) {\n\t   ttype = ID;\n\t}\n\t   \n\treturn ttype;\n}\n\n// this function is called only if the next input character is a digit\nint scan_number()\n{\n\tint ttype;\n\n\tttype = NUM;\n\tif (buffer[next_pos] != '0')\n\t\twhile (isdigit(buffer[next_pos]))\n\t\t\tnext_pos++;\n\telse // NUM is 0\n\t\tnext_pos++;\n\n\tmaximal_pos = next_pos - 1;\n\n\tcopy_token_string_from_buffer();\n\treturn ttype;\n}\n\nint getToken()\n{\n\tchar c;\n\tint ttype;\n\n\tskip_space_and_set_positions();\n\n\tc = buffer[next_pos];\n\tnext_pos++;\n\n\tswitch (c)\n\t{\n\t\tcase '.': ttype = DOT; break;\n\t\tcase '+': ttype = PLUS; break;\n\t\tcase '-': ttype = MINUS; break;\n\t\tcase '_': ttype = UNDERSCORE; break;\n\t\tcase '/': ttype = DIV; break;\n\t\tcase '*': ttype = MULT; break;\n\t\tcase '=': ttype = EQUAL; break;\n\t\tcase ':': ttype = COLON; break;\n\t\tcase ',': ttype = COMMA; break;\n\t\tcase ';': ttype = SEMICOLON; break;\n\t\tcase '[': ttype = LBRAC; break;\n\t\tcase ']': ttype = RBRAC; break;\n\t\tcase '(': ttype = LPAREN; break;\n\t\tcase ')': ttype = RPAREN; break;\n\t\tcase '<':\n\t\t\t/*\n\t\t\t * TODO: Write code to handle <= and << here\n\t\t\t */\n\t\t\t \n\t        c = buffer[next_pos];\n            if (c == '=') {\n                ttype = LTEQ;\n                next_pos++;     //increment next_pos so that getToken() retrieves the correct char in the buffer\n            }\n            else if (c == '>') {\n\t   \t        ttype = NOTEQUAL;\n\t   \t        next_pos++;     //increment next_pos so that getToken() retrieves the correct char in the buffer\n            } \n\t\t    else if (c == '<') {\n\t\t\t    ttype = LSHIFT;\n\t\t\t    next_pos++;     //increment next_pos so that getToken() retrieves the correct char in the buffer\n\t\t    }\n            else {\n                ttype = LESS;\n                maximal_pos = next_pos - 1;\n            }\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\t/*\n\t\t\t * TODO: Wriet code to handle >= and >> here\n\t\t\t */\n\t\t\t \n\t\t    c = buffer[next_pos];\n            if (c == '=') {\n                ttype = GTEQ;\n                next_pos++;     //increment next_pos so that getToken() retrieves the correct char in the buffer\n            }\n\t\t\telse if (c == '>') {\n\t\t\t\tttype = RSHIFT;\n\t\t\t\tnext_pos++;     //increment next_pos so that getToken() retrieves the correct char in the buffer\n\t\t\t}\t\n            else {\n                ttype = GREATER;\n                maximal_pos = next_pos - 1;\n            }\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tif (isdigit(c))\n\t\t\t{\n\t\t\t\tnext_pos--;\n\t\t\t\tttype = scan_number();\n\t\t\t}\n\t\t\telse if (isalpha(c)) \n\t\t\t{\n\t\t\t\t// token is either a keyword or ID or INTID or REALID\n\t\t\t\tnext_pos--;\n\t\t\t\tttype = scan_id_keyword_intid_realid();\n\t\t\t\t/* \n\t\t\t\t * TODO: Write code to handle INTID and REALID\n\t\t\t\t * It might be better to replace scan_id_keyword() \n\t\t\t\t * with a function that handles INTID and REALID \n\t\t\t\t * in addition to ID and keywords\n\t\t\t\t */\n\t\t\t}\n\t\t\telse if (c == EOF)\n\t\t\t  ttype = EOF;\n\t\t\telse\n\t\t\t  ttype = ERROR;\n\t\t\tbreak;\n\t}\t// End Switch\n\treturn ttype;\n}\n\nint main()\n{\n\tint ttype;\n\n\twhile (!feof(stdin))\n\t{\n\t\treadNextLine();\n\t\t//printBuffer();\n\t\twhile ((ttype = getToken()) != EOF)\n\t\t{\n\t\t\t/*  EOF indicates that we have reached the end of buffer */\n\t\t\t// printBuffer();\n\t\t\tprintf(\"%d %d \", line_no, ttype);\n\t\t\tif ((ttype == NUM) || (ttype == ID) || \n\t\t\t\t(ttype == INTID) || (ttype == REALID))\n\t\t\t{\n\t\t\t\tprintf(\"%s \\n\", token);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintReserved(ttype);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"]],"start1":0,"start2":0,"length1":0,"length2":9919}]],"length":9919}
{"contributors":[],"silentsave":false,"ts":1380578037978,"patch":[[{"diffs":[[0,"project "],[-1,"1"],[1,"2"],[0,"\n*/\n\n#in"]],"start1":27,"start2":27,"length1":17,"length2":17}]],"length":9919,"saved":false}
